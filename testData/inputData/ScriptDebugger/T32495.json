{
    "Branching": "/*\n* branchingFunction stub:\n*\n* The name of the function can be changed to anything you like.\n*\n* The function will be passed one 'options' argument that has the following fields:\n*   'record' - object {} or array [] depending on the data source.\n*   'settings' - all custom settings in scope for the router currently running.\n* The function needs to return an array of integers representing the branch indices that should process the record.\n* Throwing an exception will return an error for the record.\n*/\nfunction branching (options) {\n  return [0]\n}",
    "ContentBasedFlowRouter": "/*\n* contentBasedFlowRouter stub:\n*\n* The name of the function can be changed to anything you like.\n*\n* The function will be passed one 'options' argument that has the following fields:\n*   'httpHeaders' - A JSON object containing the http headers received in the request from the trading partner.\n*                   For example: { as2-from: 'OpenAS2_appA', as2-to: 'OpenAS2_appB' }\n*   'mimeHeaders' - A JSON object containing the mime headers from the mime part containing EDI message.\n*                   For example: {  content-type:application/edi-x12, content-disposition: Attachment; filename=rfc1767.dat }\n*   'rawMessageBody' - A String containing unencrypted edi/xml content.\n*\n* The function needs to return an object containing '_flowId' and '_exportId' as properties of the flow that should be run.\n* To signal a failure throw an exception.\n*/\nfunction contentBasedFlowRouter (options) {\n  let returnObj = {\n    _flowId: \"<_flowId>\", // flow_id is required for downstream processing.\n    _exportId: \"<_exportId>\" // the '_id' of the listener that should be run.\n  }\n  return returnObj\n}",
    "Filter": "/*\n* filterFunction stub:\n*\n* The name of the function can be changed to anything you like.\n*\n* The function will be passed one 'options' argument that has the following fields:\n*   'record' - object {} or array [] depending on the data source.\n*   'pageIndex' - 0 based. context is the batch export currently running.\n*   'lastExportDateTime' - delta exports only.\n*   'currentExportDateTime' - delta exports only.\n*   'settings' - all custom settings in scope for the filter currently running.\n* The function needs to return true or false.  i.e. true indicates the record should be processed.\n* Throwing an exception will return an error for the record.\n*/\nfunction filter (options) {\n  return true\n}",
    "FormInit": "/*\n* formInit function stub:\n*\n* The name of the function can be changed to anything you like.\n*\n* The function will be passed one 'options' argument that has the following fields:\n*   'resource' - the resource being viewed in the UI.\n*   'parentResource' - the parent of the resource being viewed in the UI.\n*   'grandparentResource': the grandparent of the resource being viewed in the UI.\n*   'license' - integration apps only.  the license provisioned to the integration.\n*   'parentLicense' - integration apps only. the parent of the license provisioned to the integration.\n*   'sandbox' - boolean value indicating whether the script is invoked for sandbox.\n*\n* The function needs to return a form object for the UI to render.\n* Throwing an exception will signal an error.\n*/\nfunction formInit (options) {\n  return options.resource.settingsForm.form\n}",
    "HandleRequest": "/*\n* handleRequest function stub:\n*\n* The name of the function can be changed to anything you like.\n*\n* The function will be passed one 'options' argument that has the following fields:\n*   'method' - http request method (uppercase string).\n*   'headers' - http request headers (object).  \n*   'queryString' - http request query string (object).\n*   'body' - parsed http request body (object, or undefined if unable to parse).\n*   'rawBody' - raw http request body (string).\n*   'sandbox' - boolean value indicating whether the api is invoked for sandbox.\n*\n* The function needs to return a response object that has the following fields:\n*   'statusCode' - http response status code (number).\n*   'headers' - http response headers overrides (object, optional).\n*   'body' - http response body (string or object).\n* Throwing an exception will signal an error.\n*/\nfunction handleRequest (options) {\n  return {\n    statusCode: 200,\n    headers: { },\n    body: options.body\n  }\n}",
    "PostAggregate": "/*\n* postAggregateFunction stub:\n*\n* The name of the function can be changed to anything you like.\n*\n* The function will be passed one 'options' argument that has the following fields:\n*   'postAggregateData' - a container object with the following fields:\n*     'success' - true if data aggregation was successful, false otherwise.\n*     '_json' - information about the aggregated data transfer.  For example, the name of the aggregated file on the FTP site.\n*     'code' - error code if data aggregation failed.\n*     'message' - error message if data aggregation failed.\n*     'source' - error source if data aggregation failed.\n*   '_importId' - the _importId currently running.\n*   '_connectionId' - the _connectionId currently running.\n*   '_flowId' - the _flowId currently running.\n*    '_integrationId' - the _integrationId currently running.\n*   '_parentIntegrationId' - the parent of the _integrationId currently running.\n*   'settings' - all custom settings in scope for the import currently running.\n*   'sandbox' - boolean value indicating whether the script is invoked for sandbox.\n*   'testMode' - boolean flag indicating test mode and previews.\n*\n* The function doesn't need a return value.\n* Throwing an exception will signal a fatal error.\n*/\nfunction postAggregate (options) {\n}",
    "PostMap": "/*\n* postMapFunction stub:\n*\n* The name of the function can be changed to anything you like.\n*\n* The function will be passed one argument 'options' that has the following fields:\n*   'preMapData' - an array of records representing the page of data before it was mapped.  A record can be an object {} or array [] depending on the data source.\n*   'postMapData' - an array of records representing the page of data after it was mapped.  A record can be an object {} or array [] depending on the data source.\n*   '_importId' - the _importId currently running.\n*   '_connectionId' - the _connectionId currently running.\n*   '_flowId' - the _flowId currently running.\n*   '_integrationId' - the _integrationId currently running.\n*   '_parentIntegrationId' - the parent of the _integrationId currently running.\n*   'settings' - all custom settings in scope for the import currently running.\n*   'sandbox' - boolean value indicating whether the script is invoked for sandbox.\n*   'testMode' - boolean flag indicating test mode and previews.\n*\n* The function needs to return an array, and the length MUST match the options.data array length.\n* Each element in the array represents the actions that should be taken on the record at that index.\n* Each element in the array should have the following structure:\n*   'data' - the modified/unmodified record that should be passed along for processing.\n*   'errors' - used to report one or more errors for the specific record.  Each error must have the following fields: {code: '', message: '', source: '' }\n* Returning an empty object {} for a specific record will indicate that the record should be ignored.\n* Returning both 'data' and 'errors' for a specific record will indicate that the record should be processed but errors should also be logged.\n* Throwing an exception will fail the entire page of records.\n*/\nfunction postMap (options) {\n  return options.postMapData.map((d) => {\n    return {\n      data: d\n    }\n  })\n}",
    "PostResponseMap": "/*\n* postResponseMapFunction stub:\n*\n* The name of the function can be changed to anything you like.\n*\n* The function will be passed one 'options' argument that has the following fields:\n*   'postResponseMapData' - an array of records representing the page of data after response mapping is completed. A record can be an object {} or array [] depending on the data source.\n*   'responseData' - the array of responses for the page of data.  An individual response will have the following fields:\n*      'statusCode' - 200 is a success.  422 is a data error.  403 means the connection went offline.\n*      'errors' - [{code: '', message: '', source: ''}]\n*      'ignored' - true if the record was filtered/skipped, false otherwise.\n*      'data' - exports only.  the array of records returned by the export application.\n*      'id' - imports only.  the id from the import application response.\n*      '_json' - imports only.  the complete response data from the import application.\n*      'dataURI' - imports only.  a URI for the data in the import application (populated only for errored records).\n*   'oneToMany' - as configured on your export/import resource.\n*   'pathToMany' - as configured on your export/import resource.\n*   '_exportId' - the _exportId currently running.\n*   '_importId' - the _importId currently running.\n*   '_connectionId' - the _connectionId currently running.\n*   '_flowId' - the _flowId currently running.\n*   '_integrationId' - the _integrationId currently running.\n*   '_parentIntegrationId' - the parent of the _integrationId currently running.\n*   'settings' - all custom settings in scope for the export/import currently running.\n*   'sandbox' - boolean value indicating whether the script is invoked for sandbox.\n*   'testMode' - boolean flag indicating test mode and previews.\n*\n* The function needs to return the postResponseMapData array provided by options.postResponseMapData.  The length of postResponseMapData MUST remain unchanged.  Elements within postResponseMapData can be changed however needed.\n* Throwing an exception will signal a fatal error and fail the entire page of records.\n*/\nfunction postResponseMap (options) {\n  return options.postResponseMapData\n}",
    "PostSubmit": "/*\n* postSubmitFunction stub:\n*\n* The name of the function can be changed to anything you like.\n*\n* The function will be passed one 'options' argument that has the following fields:\n*  'preMapData' - an array of records representing the page of data before it was mapped.  A record can be an object {} or array [] depending on the data source.\n*  'postMapData' - an array of records representing the page of data after it was mapped.  A record can be an object {} or array [] depending on the data source.\n*  'responseData' - an array of responses for the page of data that was submitted to the import application.  An individual response will have the following fields:\n*    'statusCode' - 200 is a success.  422 is a data error.  403 means the connection went offline.\n*    'errors' - [{code: '', message: '', source: ''}]\n*    'ignored' - true if the record was filtered/skipped, false otherwise.\n*    'id' - the id from the import application response.\n*    '_json' - the complete response data from the import application.\n*    'dataURI' - if possible, a URI for the data in the import application (populated only for errored records).\n*  '_importId' - the _importId currently running.\n*  '_connectionId' - the _connectionId currently running.\n*  '_flowId' - the _flowId currently running.\n*  '_integrationId' - the _integrationId currently running.\n*  '_parentIntegrationId' - the parent of the _integrationId currently running.\n*  'settings' - all custom settings in scope for the import currently running.\n*   'sandbox' - boolean value indicating whether the script is invoked for sandbox.\n*   'testMode' - boolean flag indicating test mode and previews.\n*\n* The function needs to return the responseData array provided by options.responseData. The length of the responseData array MUST remain unchanged.  Elements within the responseData array can be modified to enhance error messages, modify the complete _json response data, etc...\n* Throwing an exception will fail the entire page of records.\n*/\nfunction postSubmit (options) {\n  return options.responseData\n}",
    "PreSavePage": "/*\n* preSavePageFunction stub:\n*\n* The name of the function can be changed to anything you like.\n*\n* The function will be passed one 'options' argument that has the following fields:\n*   'data' - an array of records representing one page of data. A record can be an object {} or array [] depending on the data source.\n*   'files' - file exports only. files[i] contains source file metadata for data[i]. i.e. files[i].fileMeta.fileName.\n*   'errors' - an array of errors where each error has the structure {code: '', message: '', source: '', retryDataKey: ''}.\n*   'retryData' - a dictionary object containing the retry data for all errors: {retryDataKey: { data: <record>, stage: '', traceKey: ''}}.\n*   '_exportId' - the _exportId currently running.\n*   '_connectionId' - the _connectionId currently running.\n*   '_flowId' - the _flowId currently running.\n*   '_integrationId' - the _integrationId currently running.\n*   '_parentIntegrationId' - the parent of the _integrationId currently running.\n*   'pageIndex' - 0 based. context is the batch export currently running.\n*   'lastExportDateTime' - delta exports only.\n*   'currentExportDateTime' - delta exports only.\n*   'settings' - all custom settings in scope for the export currently running.\n*   'sandbox' - boolean value indicating whether the script is invoked for sandbox.\n*   'testMode' - boolean flag indicating test mode and previews.\n*\n* The function needs to return an object that has the following fields:\n*   'data' - your modified data.\n*   'errors' - your modified errors.\n*   'abort' - instruct the batch export currently running to stop generating new pages of data.\n*   'newErrorsAndRetryData' - return brand new errors linked to retry data: [{retryData: <record>, errors: [<error>]}].\n* Throwing an exception will signal a fatal error and stop the flow.\n*/\nfunction preSavePage (options) {\n  // sample code that simply passes on what has been exported\n  return {\n    data: options.data,\n    errors: options.errors,\n    abort: false,\n    newErrorsAndRetryData: []\n  }\n}",
    "Transform": "/*\n* transformFunction stub:\n*\n* The name of the function can be changed to anything you like.\n*\n* The function will be passed one 'options' argument that has the following fields:\n*   'record' - object {} or array [] depending on the data source.\n*   'settings' - all custom settings in scope for the transform currently running.\n* The function needs to return the transformed record.\n* Throwing an exception will return an error for the record.\n*/\nfunction transform (options) {\n  return options.record\n}",
    "PreMap": "/*\n* preMapFunction stub:\n*\n* The name of the function can be changed to anything you like.\n*\n* The function will be passed one 'options' argument that has the following fields:\n*   'data' - an array of records representing the page of data before it has been mapped.  A record can be an object {} or array [] depending on the data source.\n*   '_importId' - the _importId currently running.\n*   '_connectionId' - the _connectionId currently running.\n*   '_flowId' - the _flowId currently running.\n*   '_integrationId' - the _integrationId currently running.\n*   '_parentIntegrationId' - the parent of the _integrationId currently running.\n*   'settings' - all custom settings in scope for the import currently running.\n*   'sandbox' - boolean value indicating whether the script is invoked for sandbox.\n*   'testMode' - boolean flag indicating test mode and previews.\n*\n* The function needs to return an array, and the length MUST match the options.data array length.\n* Each element in the array represents the actions that should be taken on the record at that index.\n* Each element in the array should have the following structure:\n*   'data' - the modified/unmodified record that should be passed along for processing.\n*   'errors' -  used to report one or more errors for the specific record.  Each error must have the following fields: {code: '', message: '', source: '' }\n* Returning an empty object {} for a specific record will indicate that the record should be ignored.\n* Returning both 'data' and 'errors' for a specific record will indicate that the record should be processed but errors should also be logged.\n* Throwing an exception will fail the entire page of records.\n*/\nfunction preMap (options) {\n  return options.data.map((d) => {\n    return {\n      data: d\n    }\n  })\n}"
}